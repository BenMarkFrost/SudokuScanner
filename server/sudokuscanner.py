"""
This file contains high level management functions for the analysis of images.
"""

import numpy as np 
import cv2
from server import digitfinder
from server.Frame import Frame
from server.Client import Client
import time
from threading import Thread
from func_timeout import FunctionTimedOut
import copy
import imutils

# clientsDict is a dictionary of key value pairs comprising of the browser_id: client object.
# The browser_id is generated by the client browser
# Client objects are created when a new client connects
clientsDict = {}



def scan(browser_id, img, frame_id):
    """
    Scan() holds the main flow of the analysis and calls the other functions.
    There is one call to scan() for each frame passed into the API.

    @params
    browser_id, frame_id : int
    img : 3d Numpy array of shape (x,y,3)

    @returns
    Frame object
    """

    global clientsDict

    try:
        client = clientsDict[browser_id]
    
    except:

        client = Client(browser_id)
        clientsDict[browser_id] = client
        print("New client: " + str(browser_id))
    

    frame = Frame(img, frame_id)
    frame.startTime = digitfinder.current_milli_time()

    # Frames are registered to their client during execution to keep track of them.
    client.registerFrame(frame.frame_id)


    """
    Step 1 - Finding the border
    """

    frame.thresh, frame.gray = digitfinder.calculateThreshold(frame.img)

    frame.border = digitfinder.findContours(frame.thresh)
    
    if frame.border is None:
        frame.outputImage = np.zeros(frame.img.shape)
    else:
        """
        Step 2 - Solving the sudoku
        """
        manageClients(frame, client)

        frame.skewedSolution = digitfinder.warp(frame.img, frame.combinedDigits, frame.border)

        frame.outputImage = digitfinder.combineBorderAndImg(frame.border, frame.skewedSolution)

    frame.endTime = digitfinder.current_milli_time()

    """
    Step 3 - Waiting if neccessary
    """

    frameBuffer(frame, client)

    client.deregisterFrame(frame.frame_id)

    return frame



def manageClients(frame, client):
    """
    ManageClients() is called to determine if a frame should be re-analysed.

    @params 
    frame : Frame object
    client : Client object

    @returns
    none
    """

    global clientsDict
    
    timeSinceAnalysed = digitfinder.current_milli_time() - client.lastAnalysedTime

    # Each frame outputs the saved output in their client object.
    frame.combinedDigits = client.savedOutput

    # If it is less than 500ms since the last time a frame from this client was analysed, 
    # or less than 1 second and a solution has already been found for that client,
    # return the saved solution stored for that client.
    if (timeSinceAnalysed < 500) or (timeSinceAnalysed < 1000 and client.solved == True and client.reAnalyse == False):
        return

    client.lastAnalysedTime = digitfinder.current_milli_time()

    # Spawn a thread to handle further analysis.
    thread = Thread(target = analyseFrame, args = (frame, client), daemon=True)
    thread.start()

    frame.solutionFrame = True




def analyseFrame(frame, client):
    """
    AnalyseFrame() is called on a thread to run and interpret the results of findSudoku().

    @params
    frame : Frame object
    client : Client object

    @returns
    none
    """

    print("Started threaded frame for " + str(frame.frame_id))

    combinedDigits, background, currentFrameSolved = findSudoku(frame)

    # 1) If analysis on this frame has resulted in a solved sudoku, 
    # store this solution as the new saved output in the client object.
    # 2) If no solution in this frame was found, but the client has never been solved,
    # store this partial solution as the new saved output in the client object.
    if currentFrameSolved or not client.solved:
        print("Replacing image")
        client.savedOutput = combinedDigits
        client.backgroundForOutput = background
    if currentFrameSolved:
        client.solved = True

    # Only signal that this client is in need of analysis if this frame was not solved.
    client.reAnalyse = not currentFrameSolved

    client.lastAnalysedTime = digitfinder.current_milli_time()

    print("Written threaded frame for " + str(frame.frame_id))
    



def findSudoku(frame):
    """
    FindSudoku() attempts to find a sudoku in the given frame.

    @params
    frame : Frame object

    @returns
    combinedDigits : 3d Numpy array of shape (300,300,3)
    dewarpedimg : 3d Numpy array of shape (300,300,3)
    isItSudoku : Boolean
    """

    dewarpedimg = digitfinder.dewarp(frame.gray, frame.border)

    digits = digitfinder.splitByDigits(dewarpedimg)

    toNumbers = digitfinder.classifyDigits(digits)

    originals = copy.deepcopy(toNumbers)

    solvedSudoku = None

    # The hardest sudoku found online had 17 digits. Any less than this 
    # and it's safe to assume there has been a classification error.
    if np.count_nonzero(toNumbers) > 16:
        print(f"Attempting solve with {np.count_nonzero(toNumbers)} numbers in puzzle")

        try:
            solvedSudoku = digitfinder.solve(toNumbers)
            print("Sudoku solver:", digitfinder.solve.cache_info())
        except FunctionTimedOut:
            print("Sudoku solve timed out")
            solvedSudoku = None
    else:
        print("Too few digits recognised")
        solvedSudoku = None

    isItSudoku = False

    # End with either the solution or the original numbers.
    try:
        solvedSudoku = np.subtract(solvedSudoku, originals)
        isItSudoku = True
    except:
        solvedSudoku = toNumbers
        

    (w,h) = dewarpedimg.shape
    # Width of one cell
    width = int(h / 9.0)
    combinedDigits = digitfinder.renderDigits(solvedSudoku, width, isItSudoku)

    print("Digit renderer:", digitfinder.renderDigits.cache_info())

    return combinedDigits, dewarpedimg, isItSudoku



def frameBuffer(frame, client):
    """
    FrameBuffer() holds frames in a holding loop until all frames entering the API before it have finished processing.

    @params
    frame : Frame object
    client : Client object

    @returns
    none
    """

    for i in range(5):
        earliestFrame = client.next()
        if int(earliestFrame) == int(frame.frame_id):
            if (i > 0):
                print(frame.frame_id, "released")
            break
        print(f"Waiting for {earliestFrame}, I'm: {frame.frame_id}")
        if i == 4:
            print("Gave up waiting")
            # client.purgeBefore(frame.frame_id)
            break
        # Sleep for 50ms
        time.sleep(0.05)



def getSolution(browser_id):
    """
    GetSolution() calculates the solution to the current sudoku as a complete image to download.
    This is only called by app.py.

    @params
    browser_id : int

    @returns
    outputImage : 3d Numpy array of shape (600,600,3)
    """

    global clientsDict

    solutionOutputSize = 600

    try:
        client = clientsDict[browser_id]

        background = cv2.cvtColor(client.backgroundForOutput, cv2.COLOR_GRAY2RGB)

        # Overlay the solution and the background for the puzzle, so that the soloution can be viewed.
        outputImage = cv2.add(np.uint8(client.savedOutput), np.uint8(background))

        outputImage = cv2.resize(outputImage, (solutionOutputSize, solutionOutputSize))

        return outputImage
    except Exception as e:
        print(e)
        return np.zeros((solutionOutputSize,solutionOutputSize,3))




# Scanning a test file at startup ensures that tensorflow is properly set up
# This removes a delay when scanning a file for the first time in produciton.
# left = cv2.imread("IMG_2511.JPG")
# img = imutils.resize(left, 640)
# scan(1, img, 1)

print("SudokuScanner started successfully")